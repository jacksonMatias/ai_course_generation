"""
Utilities for post-processing Markdown generated by the LLM:

1. **Cleaning** – normalise whitespace, collapse >2 blank lines, strip
   trailing spaces.
2. **Table of Contents** – auto-insert a TOC up to a configurable depth.
3. **Persistence** – helper to write the final Markdown to disk.

All functionality is encapsulated in `MarkdownProcessor`, keeping the
rest of the codebase free from low-level string-munging details.

Author : AI-Course-Generator
Created: 2025-08-04
"""

from __future__ import annotations

import re
import textwrap
from pathlib import Path
from typing import List, Tuple


_HEADING_RE = re.compile(r"^(#{1,6})\s+(.+)$")


class MarkdownProcessor:
    """
    Stateless helper – each method returns *new* strings, never mutates
    the input.
    """

    # ------------------------------------------------------------------ #
    # Public façade                                                      #
    # ------------------------------------------------------------------ #
    def process(
        self,
        markdown: str,
        *,
        toc: bool = True,
        max_toc_depth: int = 3,
    ) -> str:
        """
        Clean Markdown and (optionally) prepend a table of contents.
        """
        cleaned = self._clean(markdown)

        if toc:
            toc_block = self._build_toc(cleaned, max_depth=max_toc_depth)
            cleaned = "\n".join([toc_block, "", cleaned])

        return cleaned

    def save(self, markdown: str, path: Path) -> None:
        """
        Write Markdown text to `path`, creating parent directories.
        """
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(markdown, encoding="utf-8")

    # ------------------------------------------------------------------ #
    # Cleaning                                                           #
    # ------------------------------------------------------------------ #
    @staticmethod
    def _clean(md: str) -> str:
        """
        Light-weight cleanup: strip trailing/leading whitespace, collapse
        excessive blank lines, normalise indentation.
        """
        # Remove leading/trailing whitespace
        md = md.strip()

        # Dedent common leading whitespace (if GPT added it accidentally)
        md = textwrap.dedent(md)

        # Collapse 3+ blank lines → 2
        md = re.sub(r"\n{3,}", "\n\n", md)

        # Remove trailing spaces
        md = re.sub(r"[ \t]+$", "", md, flags=re.MULTILINE)

        return md

    # ------------------------------------------------------------------ #
    # Table-of-contents                                                  #
    # ------------------------------------------------------------------ #
    @classmethod
    def _build_toc(cls, md: str, *, max_depth: int = 3) -> str:
        """
        Parse headings and build a Markdown list linking to the anchors
        GitHub / GitLab style (`#heading-with-dashes`).
        """
        headings: List[Tuple[int, str]] = []

        for line in md.splitlines():
            match = _HEADING_RE.match(line)
            if not match:
                continue
            level = len(match.group(1))
            title = match.group(2).strip()
            if 1 < level <= max_depth:  # skip H1 (document title)
                headings.append((level, title))

        if not headings:
            return ""  # nothing to build

        toc_lines: List[str] = ["## Table of Contents"]
        for level, title in headings:
            indent = "  " * (level - 2)
            anchor = cls._slugify(title)
            toc_lines.append(f"{indent}- [{title}](#{anchor})")

        return "\n".join(toc_lines)

    @staticmethod
    def _slugify(text: str) -> str:
        """
        Convert heading text into a GitHub-compatible anchor slug.
        """
        slug = re.sub(r"[^\w\s-]", "", text).strip().lower()
        slug = re.sub(r"\s+", "-", slug)
        return slug
